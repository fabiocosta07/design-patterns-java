/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package designPatterns.solidPrinciples.openClose;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Stream;

//OCP Open Close Principle + Specification Design pattern
// classes should be open for extension and closed for modification

public class App {

    public static void main(String[] args) {
        Product product1 = new Product(Color.BLUE,Size.SMALL);
        Product product2 = new Product(Color.GREEN,Size.MEDIUM);
        Product product3 = new Product(Color.WHITE,Size.LARGE);
        Product product4 = new Product(Color.WHITE,Size.MEDIUM);

        List<Product> products = new ArrayList<>();
        products.add(product1);
        products.add(product2);
        products.add(product2);
        products.add(product4);

        ProductFilter productFilter = new ProductFilter();
        productFilter.filterColor(products, Color.BLUE)
            .forEach(p -> System.out.println(p));

        BetterProductFilter betterProductFilter = new BetterProductFilter();
        betterProductFilter.filterSpecification(products, new ColorSpecification(Color.BLUE))
                .forEach(p -> System.out.println(p));

        betterProductFilter.filterSpecification(products, new ColorSpecification(Color.BLUE))
                .forEach(p -> System.out.println(p));

        betterProductFilter.filterSpecification(products,new AndSpecification(
                new ColorSpecification(Color.WHITE)
                , new SizeSpecification(Size.MEDIUM)))
                .forEach(p -> System.out.println(p));
    }
}

class Product {
    Color color;
    Size size;

    public Product(Color color, Size size) {
        this.color = color;
        this.size = size;
    }

    @Override
    public String toString() {
        return "Product{" +
                "color=" + color +
                ", size=" + size +
                '}';
    }
}

enum Color {
    BLUE,GREEN,WHITE
}

enum Size {
    SMALL, MEDIUM, LARGE
}

class ProductFilter {
    Stream<Product>  filterColor(List<Product> products, Color color) {
        return products.stream().filter(p -> p.color == color);
    }
    Stream<Product>  filterSize(List<Product> products, Size size) {
        return products.stream().filter(p -> p.size == size);
    }
}

/////////////////

interface Filter<T> {
    Stream<T> filterSpecification(List<T> items, Specification<T> specification);
}

interface Specification<T> {
    boolean isSatisfied(T t);
}

class ColorSpecification implements Specification<Product> {
    Color color;

    public ColorSpecification(Color color) {
        this.color = color;
    }
    @Override
    public boolean isSatisfied(Product p) {
        return color== p.color;
    }
}

class SizeSpecification implements Specification<Product> {
    Size size;

    public SizeSpecification(Size size) {
        this.size = size;
    }

    @Override
    public boolean isSatisfied(Product product) {
        return size == product.size;
    }
}

class AndSpecification implements Specification<Product> {

    Specification<Product> first, second;

    public AndSpecification(Specification<Product> first, Specification<Product> second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean isSatisfied(Product product) {
        return first.isSatisfied(product) && second.isSatisfied(product);
    }
}

class BetterProductFilter implements Filter{

    @Override
    public Stream filterSpecification(List items, Specification specification) {
        return items.stream().filter(p -> specification.isSatisfied(p));
    }
}